# Сравнение производительности ArrayList и LinkedList

## Описание проекта

Лабораторная работа по сравнительному анализу производительности основных операций 
в коллекциях `ArrayList` и `LinkedList` в Java. Проект реализован как Maven-приложение 
с полным набором unit-тестов и документацией.

## Цель работы

Провести сравнительный анализ временной сложности основных операций:
- Добавление элементов (в конец и в начало)
- Получение элементов по индексу
- Удаление элементов (из начала и из конца)

## Технические характеристики

- **Язык программирования**: Java 11
- **Система сборки**: Maven
- **Тестирование**: JUnit 5
- **Документация**: JavaDoc

## Структура проекта
src/main/java/com/benchmark/
├── Benchmark.java # Утилитарный класс для измерений производительности
├── ListPerformanceTester.java # Основной класс приложения
└── Result.java # Класс для хранения результатов тестирования

src/test/java/com/benchmark/
└── ListPerformanceTesterTest.java # Unit-тесты

target/surefire-reports/ # Отчеты о выполнении тестов


## Классы и их назначение

### 1. Benchmark
Утилитарный класс, содержащий методы для измерения производительности:
- `testAdd()` - добавление в конец
- `testAddFirst()` - добавление в начало  
- `testGet()` - получение по индексу
- `testDeleteFirst()` - удаление из начала
- `testDeleteLast()` - удаление из конца

### 2. ListPerformanceTester
Основной класс приложения, который:
- Запускает тесты для различных размеров данных (1000, 2000, 5000 операций)
- Выводит результаты в табличном формате
- Сравнивает производительность ArrayList и LinkedList

### 3. Result
Класс-контейнер для хранения результатов тестирования:
- Название метода
- Тип списка
- Количество операций
- Время выполнения
- Тип операции

## Запуск проекта

### Требования
- Java 11 или выше
- Maven 3.6 или выше

### Сборка проекта
mvn clean compile

# Запуск тестов
mvn test
# Запуск приложения
mvn compile exec:java -Dexec.mainClass="com.benchmark.ListPerformanceTester"
# Генерация отчетов
mvn javadoc:javadoc

### Пример вывода программы
=== Сравнение производительности ArrayList и LinkedList ===

Тестирование для 1000 операций:
================================================================================
Method           | List Type   | Operations |    Time (ms) | Type    
----------------------------------------------------------------------------
add              | ArrayList   |       1000 |        0.123 | add     
add              | LinkedList  |       1000 |        0.456 | add     
addFirst         | ArrayList   |       1000 |        1.234 | add     
addFirst         | LinkedList  |       1000 |        0.123 | add     
get              | ArrayList   |       1000 |        0.045 | get     
get              | LinkedList  |       1000 |        2.345 | get     
deleteFirst      | ArrayList   |       1000 |        1.567 | delete  
deleteFirst      | LinkedList  |       1000 |        0.234 | delete  
deleteLast       | ArrayList   |       1000 |        0.078 | delete  
deleteLast       | LinkedList  |       1000 |        0.089 | delete  

Сравнение производительности:
--------------------------------------------------
add        : ArrayList:  0.123 ms, LinkedList:  0.456 ms | Быстрее: ArrayList  (в 3.71 раз)
addFirst   : ArrayList:  1.234 ms, LinkedList:  0.123 ms | Быстрее: LinkedList (в 10.03 раз)
get        : ArrayList:  0.045 ms, LinkedList:  2.345 ms | Быстрее: ArrayList  (в 52.11 раз)
deleteFirst: ArrayList:  1.567 ms, LinkedList:  0.234 ms | Быстрее: LinkedList (в 6.70 раз)
deleteLast : ArrayList:  0.078 ms, LinkedList:  0.089 ms | Быстрее: ArrayList  (в 1.14 раз)

### Теоретические ожидания
ArrayList
Быстро: добавление в конец (амортизированное O(1)), получение по индексу (O(1)), удаление из конца (O(1))
Медленно: добавление/удаление в начало (O(n)), добавление/удаление в середину (O(n))

LinkedList
Быстро: добавление в начало/конец (O(1)), удаление из начала (O(1))
Медленно: получение по индексу (O(n)), удаление из конца (O(n) для односвязного списка)

Результаты тестирования
На основе проведенных измерений можно сделать следующие выводы:

Операции добавления в конец - ArrayList обычно быстрее благодаря оптимизации массива
Операции добавления в начало - LinkedList значительно быстрее
Операции получения по индексу - ArrayList значительно быстрее (прямой доступ vs последовательный)
Операции удаления из начала - LinkedList быстрее
Операции удаления из конца - оба списка показывают схожую производительность

### Рекомендации по использованию
Используйте ArrayList когда:
Частые операции чтения по индексу
Добавление элементов происходит преимущественно в конец
Известен примерный размер коллекции

Используйте LinkedList когда:
Частые операции добавления/удаления из начала
Частые операции вставки/удаления в середине (при использовании ListIterator)
Размер коллекции сильно варьируется

### Особенности реализации
Используется наносекундное измерение времени для точности
Каждый тест выполняется на чистом экземпляре списка
Реализована защита от побочных эффектов
Полное покрытие unit-тестами
Профессиональная документация JavaDoc